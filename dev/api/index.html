<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QAOALandscapes.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://RaimelMedina.github.io/QAOALandscapes.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QAOALandscapes.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">QAOALandscapes</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.QAOA" href="#QAOALandscapes.QAOA"><code>QAOALandscapes.QAOA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QAOA(g::T; applySymmetries=true) where T &lt;: AbstractGraph</code></pre><p>Constructors for the <code>QAOA</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/qaoa.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.HxDiag-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, T2}} where {R&lt;:Real, T2&lt;:Graphs.AbstractGraph}" href="#QAOALandscapes.HxDiag-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, T2}} where {R&lt;:Real, T2&lt;:Graphs.AbstractGraph}"><code>QAOALandscapes.HxDiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HxDiag(g::T) where T&lt;: AbstractGraph</code></pre><p>Construct the mixing Hamiltonian. If the cost Hamiltonian is invariant under the parity operator <span>$\prod_{i=1}^N \sigma^x_i$</span> it is better to work in the +1 parity sector of the Hilbert space since this is more efficient. In practice, if the system size is <span>$N$</span>, the corresponding Hamiltonianwould be a vector of size <span>$2^{N-1}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/hamiltonians.jl#L98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.HxDiagSymmetric-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, T2}} where {R&lt;:Real, T2&lt;:Graphs.AbstractGraph}" href="#QAOALandscapes.HxDiagSymmetric-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, T2}} where {R&lt;:Real, T2&lt;:Graphs.AbstractGraph}"><code>QAOALandscapes.HxDiagSymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HxDiagSymmetric(T::Type{&lt;:Real}, g::S) where S &lt;: AbstractGraph</code></pre><p>Construct the mixing Hamiltonian in the positive (+1) parity sector of the Hilbert space. This means that if the system  size is N, then <code>HxDiagSymmetric</code> would be a vector of size <span>$2^{N-1}$</span>. This construction, only makes sense if the cost/problem  Hamiltonian <span>$H_C$</span> is invariant under the action of the parity operator, that is</p><p class="math-container">\[    [H_C, \prod_{i=1}^N \sigma^x_i] = 0\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/hamiltonians.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.HzzDiag-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, T2}} where {R&lt;:Real, T2&lt;:Graphs.AbstractGraph}" href="#QAOALandscapes.HzzDiag-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, T2}} where {R&lt;:Real, T2&lt;:Graphs.AbstractGraph}"><code>QAOALandscapes.HzzDiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HzzDiag(g::T) where T &lt;: AbstractGraph</code></pre><p>Construct the cost Hamiltonian. If the cost Hamiltonian is invariant under the parity operator <span>$\prod_{i=1}^N \sigma^x_i$</span> it is better to work in the +1 parity sector of the Hilbert space since this is more efficient. In practice, if the system size is <span>$N$</span>, the corresponding Hamiltonian would be a vector of size <span>$2^{N-1}$</span>. This function instead returs a vector of size <span>$2^N$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/hamiltonians.jl#L75-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.HzzDiagSymmetric-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, T2}} where {R&lt;:Real, T2&lt;:Graphs.AbstractGraph}" href="#QAOALandscapes.HzzDiagSymmetric-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, T2}} where {R&lt;:Real, T2&lt;:Graphs.AbstractGraph}"><code>QAOALandscapes.HzzDiagSymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HzzDiagSymmetric(g::T) where T &lt;: AbstractGraph
HzzDiagSymmetric(edge::T) where T &lt;: AbstractEdge</code></pre><p>Construct the cost Hamiltonian in the positive (+1) parity sector of the Hilbert space. This means that if the system  size is N, then <code>HzzDiagSymmetric</code> would be a vector of size <span>$2^{N-1}$</span>. This construction, only makes sense if the cost/problem  Hamiltonian <span>$H_C$</span> is invariant under the action of the parity operator, that is</p><p class="math-container">\[    [H_C, \prod_{i=1}^N \sigma^x_i] = 0\]</p><p>Similarly, if the input is an <code>edge</code> then it returns the corresponding <span>$ZZ$</span> operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/hamiltonians.jl#L30-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.computationalBasisWeights-Tuple{Any, Any}" href="#QAOALandscapes.computationalBasisWeights-Tuple{Any, Any}"><code>QAOALandscapes.computationalBasisWeights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computationalBasisWeights(ψ, equivClasses)</code></pre><p>Computes the computational basis weights for a given state vector <code>ψ</code> according to the provided equivalence classes, by summing up the squared magnitudes of the elements with the same equivalence class. Here <code>ψ</code> and <code>equivClasses</code> are ment to live in the same Hilbert space basis. </p><p><strong>Arguments</strong></p><ul><li><code>ψ</code>: The state vector.</li><li><code>equivClasses</code>: A Vector of Vectors, where each inner Vector contains the indices of the elements belonging to the same equivalence class.</li></ul><p><strong>Returns</strong></p><ul><li><code>basis_weights::Vector{Float64}</code>: A Vector containing the summed squared magnitudes of <code>ψ</code> for each equivalence class.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/utilities/state_utilities.jl#L76-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.fourierOptimize-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.fourierOptimize-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.fourierOptimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourierOptimize(qaoa::QAOA, Γ0::Vector{Float64}, pmax::Int)</code></pre><p>Starting from a local minima <code>Γ0</code> at <span>$p=1$</span> it performs the <code>Fourier</code> optimization strategy until the circuit depth <code>pmax</code> is reached. By default the <code>BFGS</code> optimizer is used. </p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA object </li><li><code>Γ0::Vector{Float64}</code>: Vector correponding to the local minimum from which we will construct the particular TS and then <strong>roll down</strong> from.</li></ul><p><strong>Return</strong></p><ul><li><code>result:Dict</code>. Dictionary with keys being <code>keys \in [1, pmax]</code> and values being a <code>Tuple{Float64, Vector{Float64}}</code> of cost function value and corresponding parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/fourier.jl#L116-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.gad-Union{Tuple{T}, Tuple{QAOA, Vector{T}}} where T&lt;:Real" href="#QAOALandscapes.gad-Union{Tuple{T}, Tuple{QAOA, Vector{T}}} where T&lt;:Real"><code>QAOALandscapes.gad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gad(qaoa::QAOA, init_point::Vector{T}; niter = 500, η=0.01, tol=1e-5) where T&lt;:Real</code></pre><p>Perform the Gentlest Ascent Dynamics (GAD) optimization algorithm on a QAOA problem with the goal to find index-1 saddle points.</p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: a QAOA problem instance.</li><li><code>init_point::Vector{T}</code>: the initial point in parameter space, where <code>T</code> is a subtype of <code>Real</code>.</li><li><code>niter::Int=500</code>: the maximum number of iterations to perform (optional, default is 500).</li><li><code>η::Float64=0.01</code>: the step size for the GAD algorithm (optional, default is 0.01).</li><li><code>tol::Float64=1e-5</code>: the tolerance for the gradient norm. If the norm falls below this value, the algorithm stops (optional, default is 1e-5).</li></ul><p><strong>Returns</strong></p><ul><li><code>point_history</code>: history of points during the iterations.</li><li><code>energ_history</code>: history of energy values during the iterations.</li><li><code>grad_history</code>: history of gradient norms during the iterations.</li></ul><p><strong>Usage</strong></p><p>```julia point<em>history, energ</em>history, grad<em>history = gad(qaoa, init</em>point, niter=500, η=0.01, tol=1e-5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/saddles/saddles_search.jl#L110-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.generalClassicalHamiltonian-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, Int64, Dict{Vector{Int64}, T2}}} where {R&lt;:Real, T2&lt;:Real}" href="#QAOALandscapes.generalClassicalHamiltonian-Union{Tuple{T2}, Tuple{R}, Tuple{Type{Complex{R}}, Int64, Dict{Vector{Int64}, T2}}} where {R&lt;:Real, T2&lt;:Real}"><code>QAOALandscapes.generalClassicalHamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generalClassicalHamiltonian(interaction_dict::Dict{Vector{Int64}, Float64})</code></pre><p>This function computes the classical Hamiltonian for a general <span>$p$</span>-spin Hamiltonian, that is</p><p class="math-container">\[    H_Z  = \sum_{i \in S} J_i \prod_{\alpha \in i} \sigma^z_{i_{\alpha}}\]</p><p>Above, <span>$S$</span> is the set of interaction terms which is passed as an argument in the for of a dictionary with keys being the spins participating in a given interaction and values given by the weights of such interaction term.</p><p><strong>Arguments</strong></p><ul><li><code>interaction_dict</code>: a dictionary where each key is a vector of integers representing an interaction, and each value is the weight of that interaction.</li></ul><p><strong>Returns</strong></p><ul><li><code>hamiltonian::Vector{Float64}</code>: The general <span>$p$</span> spin Hamiltonian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/hamiltonians.jl#L126-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.geometricTensor-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Array{Complex{T}, 1}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:Real}" href="#QAOALandscapes.geometricTensor-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Array{Complex{T}, 1}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:Real}"><code>QAOALandscapes.geometricTensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geometricTensor(qaoa::QAOA, params::Vector{T}, ψ0::AbstractVector{Complex{T}}) where T&lt;: Real</code></pre><p>Compute the geometricTensor of the QAOA cost function using adjoint (a reverse-mode) differentiation. We implement the algorithm  proposed in <a href="https://arxiv.org/pdf/2011.02991.pdf"><em>this reference</em></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/gradient.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.getEquivalentClasses-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#QAOALandscapes.getEquivalentClasses-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>QAOALandscapes.getEquivalentClasses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getEquivalentClasses(vec::Vector{T}; sigdigits = 5) where T &lt;: Real</code></pre><p>Computes the equivalence classes of the elements of the input vector <code>vec</code> The elements are rounded to a certain number of significant digits (default is 5) to group the states with approximately equal values.</p><p><strong>Arguments</strong></p><ul><li><code>vec::Vector{T&lt;:Real}</code></li><li><code>sigdigits=5</code>: Significant digits to which energies are rounded.</li></ul><p><strong>Returns</strong></p><ul><li><code>data_states::Dict{Float64, Vector{Int}}</code>: Keys are unique elements (rounded) and values corresponds to the index of elements with the same key.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/utilities/utils.jl#L164-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.getHessianIndex-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.getHessianIndex-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.getHessianIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getHessianIndex(qaoa::QAOA, Γ::AbstractVector{T}; checks=true, tol=1e-6) where T&lt;:Real</code></pre><p>Calculate the Hessian index of a stationary (it checks the gradient norm) point of the QAOA energy function</p><p><strong>Arguments</strong></p><ul><li><code>qaoa</code>: a QAOA object.</li><li><code>Γ</code>: a vector of parameters.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>checks=true</code>: a boolean to decide whether to check if the gradient of the cost function is smaller than a certain tolerance.</li><li><code>tol=1e-6</code>: a tolerance level for the gradient of the cost function.</li></ul><p><strong>Output</strong></p><ul><li>Returns the Hessian index, i.e., the number of negative eigenvalues of the Hessian matrix.</li></ul><p><strong>Notes</strong></p><p>The function first calculates the gradient of the cost function for the given <code>qaoa</code> and <code>Γ</code>. If <code>checks=true</code>, it asserts that the norm of this gradient is less than <code>tol</code>. It then calculates the Hessian matrix and its eigenvalues, and returns the count of eigenvalues less than zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/gradient.jl#L319-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.getInitialParameter-Union{Tuple{QAOA{T1, T, T3}}, Tuple{T3}, Tuple{T}, Tuple{T1}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.getInitialParameter-Union{Tuple{QAOA{T1, T, T3}}, Tuple{T3}, Tuple{T}, Tuple{T1}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.getInitialParameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getInitialParameter(qaoa::QAOA; spacing = 0.01, gradTol = 1e-6)</code></pre><p>Given a <code>QAOA</code> object it performs a grid search on a region of the two dimensional space spanned by <span>$\{ \gamma_1, \beta_1\}$</span> The <span>$\beta_1$</span> component is in the interval <span>$[-\pi/4, \pi/4]$</span> while the <span>$\gamma_1$</span> part is in the <span>$(0, \pi/4]$</span> for 3RRG or <span>$(0, \pi/2]$</span> for dRRG (with <span>$d\neq 3$</span>). </p><p>We then launch the <code>QAOA</code> optimization procedure from the point in the 2-dimensional grid with the smallest cost function value.</p><p><strong>Returns</strong></p><ul><li>3-Tuple containing: 1.) the cost function grid, 2.) the optimal parameter, and 3.) the optimal energy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/optimization_settings.jl#L264-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.getNegativeHessianEigval-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.getNegativeHessianEigval-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.getNegativeHessianEigval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNegativeHessianEigval(qaoa::QAOA, Γmin::Vector{Float64}, ig::Int; tsType=&quot;symmetric&quot;)</code></pre><p>Computes the approximation to the minimum (negative) eigenvalue of the Hessian at the TS obtained by padding with zeros the local minimum <code>Γmin</code>. The transition state is completely specified by the index of the γ component <code>ig</code>, and the  type of transition states (<code>&quot;symmetric&quot;</code> or <code>&quot;non_symmetric&quot;</code>). The cost of obtaining this approximate eigenvalue is basically the cost of computing two matrix elements of a Hessian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/hessian_tools.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.getNegativeHessianEigvec-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.getNegativeHessianEigvec-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.getNegativeHessianEigvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNegativeHessianEigvec(qaoa::QAOA, Γmin::Vector{Float64}, ig::Int; tsType=&quot;symmetric&quot;, doChecks=false)</code></pre><p>Computes the approximate eigenvalue and index-1 eigenvector of the Hessian at the transition state obtained from the local minimum  <code>Γmin</code>. It is completely specified by the parameters <code>iγ</code> and <code>tsType=&quot;symmetric&quot;</code>. If the optional parameter <code>doChecks=false</code> is set to <code>true</code>, then the function also returns the relative error in estimating the true eigenvalue as well as the inner product between the approximate and true eigenvector</p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA object</li><li><code>Γmin::Vector{Float64}</code>: The vector corresponding to a local minimum of QAOAₚ. </li><li><code>ig::Int</code>: Index of the γ component where the zeros are inserted. </li><li><code>tsType=&quot;symmetric&quot;</code>: In this case, the index of the β component is equal to <code>ig</code>. Otherwise, the β index is <code>ig-1</code>.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>doChecks=false</code>: In this case the function returns a dictionary with keys <code>eigvec_approx</code> and <code>eigval_approx</code>. If set to true it has additional keys =&gt; <code>change_basis</code>, <code>eigvec_fidelity</code> and <code>eigval_error</code></li></ul><p><strong>Returns</strong></p><ul><li><code>result::Dict</code> Dictionary with the following keys: <code>eigvec_approx</code>, <code>eigval_approx</code>. If <code>doChecks=true</code> the following additional keys are available: <code>change_basis</code>, <code>eigvec_fidelity</code> and <code>eigval_error</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/hessian_tools.jl#L99-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.getQAOAState-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{QAOA{T1, T2, T3}, Vector{T2}}} where {T1&lt;:Graphs.AbstractGraph, T2&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.getQAOAState-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{QAOA{T1, T2, T3}, Vector{T2}}} where {T1&lt;:Graphs.AbstractGraph, T2&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.getQAOAState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getQAOAState(q::QAOA, Γ::AbstractVector{T}) where T &lt;: Real</code></pre><p>Construct the QAOA state. More specifically, it returns the state:</p><p class="math-container">\[    |\Gamma^p \rangle = U(\Gamma^p) |+\rangle\]</p><p>with</p><p class="math-container">\[    U(\Gamma^p) = \prod_{l=1}^p e^{-i H_{B} \beta_{2l}} e^{-i H_{C} \gamma_{2l-1}}\]</p><p>and <span>$H_B, H_C$</span> corresponding to the mixing and cost Hamiltonian correspondingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/qaoa.jl#L64-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.getStateProjection-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Vector{Int64}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:CPUBackend}" href="#QAOALandscapes.getStateProjection-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Vector{Int64}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:CPUBackend}"><code>QAOALandscapes.getStateProjection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getStateProjection(qaoa::QAOA, params, stateIndex::Vector{Int64})</code></pre><p>Calculates the projection of the QAOA state onto the state subspace determined by <code>gsIndex</code>. It also returns the corresponding orthogonal complement.  The QAOA state is determined by the given parameters <code>params</code>.</p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA object.</li><li><code>params</code>: Parameters determining the QAOA state.</li><li><code>stateIndex::Vector{Int64}</code>: Indices of the ground state components.</li></ul><p><strong>Returns</strong></p><ul><li><code>normState</code>: Norm of the projection of the QAOA state onto the state subspace given by <code>stateIndex</code>.</li><li><code>normState_perp</code>: Norm of the projection of the QAOA state onto the orthogonal complement of the specificied state subspace.</li><li><code>ψIndex</code>: Normalized projection of the QAOA state onto the state subspace.</li><li><code>ψIndex_perp</code>: Normalized projection of the QAOA state onto the orthogonal complement of the state subspace.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/utilities/state_utilities.jl#L11-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.getStationaryPoints-Tuple{QAOA, Integer, Any}" href="#QAOALandscapes.getStationaryPoints-Tuple{QAOA, Integer, Any}"><code>QAOALandscapes.getStationaryPoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getStationaryPoints(
    qaoa::QAOA, 
    p::Integer,
    grid_of_points;
    printout = false, 
    threaded = false,
    method = Optim.BFGS(linesearch = Optim.BackTracking(order=3))
)</code></pre><p>Computes the stationary points of the QAOA cost function given an initial grid of points. The finer the grid the more points we should find (until saturation is reached)</p><p>The optimization is performed using the provided method (BFGS with backtracking linesearch by default). The function can operate either in single-threaded or multi-threaded mode.</p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA problem instance.</li><li><code>p::Integer</code>: Integer value related to the problem dimensionality.</li><li><code>grid_of_points</code>: Initial points in parameter space from which the optimization begins.</li><li><code>printout::Bool</code> (optional): If true, prints the final cost function value and gradient norm. Default is false.</li><li><code>threaded::Bool</code> (optional): If true, uses multi-threaded mode. Default is false.</li><li><code>method::Optim.AbstractOptimizer</code> (optional): Optimizer to use. Default is BFGS with backtracking linesearch of order 3.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: Returns a tuple containing the final energies and the corresponding parameters at the stationary points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/saddles/saddles_search.jl#L54-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.gradSquaredNorm-Union{Tuple{T}, Tuple{QAOA, AbstractVector{T}}} where T&lt;:Real" href="#QAOALandscapes.gradSquaredNorm-Union{Tuple{T}, Tuple{QAOA, AbstractVector{T}}} where T&lt;:Real"><code>QAOALandscapes.gradSquaredNorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradSquaredNorm(qaoa::QAOA, point::AbstractVector{T}) where T &lt;: Real</code></pre><p>Calculate the squared norm of the gradient of the QAOA cost function at the given point.</p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA problem instance.</li><li><code>point::AbstractVector{T}</code>: Point in parameter space at which to compute the gradient squared norm.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Returns the squared norm of the gradient at the given point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/saddles/saddles_search.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.hessianCostFunction-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.hessianCostFunction-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.hessianCostFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hessianCostFunction(qaoa::QAOA, Γ::AbstractVector{T}) where T&lt;:Real</code></pre><p>Computes the cost function Hessian at the point <span>$\Gamma$</span> in parameter space.  The computation is done analytically since it has proven to be faster than the previous implementation using <a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>ForwardDiff.jl</code></a> package</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/gradient.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.interpInitialization-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#QAOALandscapes.interpInitialization-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>QAOALandscapes.interpInitialization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpInitialization(Γp::Vector{Float64})</code></pre><p>Given an initial state <code>Γp::Vector{Float64}</code> of length <code>2p</code> it creates another vector <code>ΓInterp</code> of size <span>$2p+2$</span> with <span>$\gamma (\beta)$</span> components given by the following expression</p><p class="math-container">\[\gamma^i_{p+1} = \frac{i-1}{p} \gamma^{i-1}_{p} + \frac{p-i+1}{p}\gamma^{i}_{p}\]</p><p>and analogously for the <span>$\beta$</span> components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/interp.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.interpOptimize-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.interpOptimize-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.interpOptimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpOptimize(qaoa::QAOA, Γ0::Vector{Float64}, pmax::Int; method=Optim.BFGS(linesearch = Optim.BackTracking(order=3)))</code></pre><p>Starting from a local minima <code>Γ0</code> at <span>$p=1$</span> it performs the <code>Interp</code> optimization strategy until the circuit depth <code>pmax</code> is reached. By default the <code>BFGS</code> optimizer is used. </p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA object </li><li><code>Γ0::Vector{Float64}</code>: Vector correponding to the local minimum from which we will construct the particular TS and then <strong>roll down</strong> from.</li></ul><p><strong>Optional</strong></p><ul><li><code>method=Optim.BFGS(linesearch = Optim.BackTracking(order=3))</code>: Default optimizer and linesearch choice. For more available choices see <a href="https://julianlsolvers.github.io/Optim.jl/stable/"><em>Optim.jl</em></a> </li></ul><p><strong>Return</strong></p><ul><li><code>result:Dict</code>. Dictionary with keys being <code>keys \in [1, pmax]</code> and values being a <code>Tuple{Float64, Vector{Float64}}</code> of cost function value and corresponding parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/interp.jl#L53-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.optimizeGradSquaredNorm-Union{Tuple{T}, Tuple{QAOA, AbstractVector{T}}} where T&lt;:Real" href="#QAOALandscapes.optimizeGradSquaredNorm-Union{Tuple{T}, Tuple{QAOA, AbstractVector{T}}} where T&lt;:Real"><code>QAOALandscapes.optimizeGradSquaredNorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimizeGradSquaredNorm(qaoa::QAOA, point::AbstractVector{T}; printout=false, 
    method=Optim.BFGS(linesearch = Optim.BackTracking(order=3))) where T &lt;: Real</code></pre><p>Optimizes the squared norm of the gradient of the QAOA cost function given the initial parameter <code>point</code>.</p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA problem instance.</li><li><code>point::AbstractVector{T}</code>: Initial point in parameter space to start the optimization.</li><li><code>printout::Bool</code> (optional): If true, prints the final cost function value and gradient norm. Default is false.</li><li><code>method::Optim.AbstractOptimizer</code> (optional): Optimizer to use. Default is BFGS with backtracking linesearch of order 3.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: Returns a tuple containing the optimized parameters and the minimum cost.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/saddles/saddles_search.jl#L19-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.optimizeParameters-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{Val{:Fourier}, QAOA{T1, T, T3}, AbstractVector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.optimizeParameters-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{Val{:Fourier}, QAOA{T1, T, T3}, AbstractVector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.optimizeParameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimizeParameters(::Val{:Fourier}, qaoa::QAOA, Γ0::Vector{Float64}; printout=false)</code></pre><p>Perform optimization of the <code>QAOA</code> using the gradient descent algorithm with the <code>BFGS</code> optimizer. Here we use the alternative &quot;Fourier&quot; initialization, where instead of optimizing the usual (γ, β) parameters we optimize their frecuency components <span>$(u_{\gamma}, u_{\beta})$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>Val(:BFGS)</code>: For using the BFGS. Alternatively, <code>Val(:GD)</code> for using the <code>ADAM</code> optimizer</li><li><code>qaoa:QAOA</code>: QAOA object</li><li><code>Γ0::Vector{Float64}</code>: Initial point from where the optimization starts</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>printout=false</code>: Whether if we print something during the optimization or not</li></ul><p><strong>Returns</strong></p><p>It returns a tuple containing the following information</p><ul><li><code>parameters::Vector{Float64}</code>: Optimal parameter obtained</li><li><code>cost::Float64</code>: Value of the cost function for the optimal parameter obtained.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/optimization_settings.jl#L143-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.optimizeParametersSlice-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Integer, Vector{Int64}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.optimizeParametersSlice-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}, Integer, Vector{Int64}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.optimizeParametersSlice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimizeParametersSlice(qaoa::QAOA, ΓTs::Vector{T}, u::Vector{T};
                        method=Optim.BFGS(linesearch=LineSearches.BackTracking(order=3))) where T&lt;:Real</code></pre><p>Optimize the parameters of the QAOA along the index-1 direction of the transition state <code>ΓTs</code>. </p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA instance </li><li><code>ΓTs::Vector{T}</code>: Initial parameter vector. We assume that <code>ΓTs</code> is an index-1 saddle point and the <code>u</code> is the index-1 direction</li><li><code>u::Vector{T}</code>: Direction along which the <code>QAOA</code> cost function is going to be optimized. </li><li><code>method</code>: The optimization method to be used for the parameter optimization.   Default: <code>Optim.BFGS(linesearch=LineSearches.BackTracking(order=3))</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>f_vals::Vector{T}</code>: The minimum objective function values obtained from the optimization process for the negative and positive parameter shift cases.</li><li><code>x_vals::Vector{Vector{T}}</code>: The corresponding parameter values that yield the minimum objective function values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/optimization_settings.jl#L206-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.optimizeParametersTaped-Union{Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T}, AbstractVector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real}" href="#QAOALandscapes.optimizeParametersTaped-Union{Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T}, AbstractVector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real}"><code>QAOALandscapes.optimizeParametersTaped</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimizeParameters(qaoa::QAOA, params::AbstractVector{T};
                   method = Optim.BFGS(linesearch = Optim.BackTracking(order=3)),
                   printout::Bool = false) where T&lt;:Real</code></pre><p>Optimizes the QAOA parameters using the specified optimization method and linesearch algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: A QAOA instance representing the problem to be solved.</li><li><code>params::AbstractVector{T}</code>: The initial guess for the optimization parameters, where T is a subtype of Real.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method</code>: The optimization method to be used (default: <code>Optim.BFGS(linesearch = Optim.BackTracking(order=3))</code>).</li><li><code>printout::Bool</code>: Whether to print optimization progress information (default: <code>false</code>).</li></ul><p>!!! Important</p><ul><li><code>diffMode</code> = :adjoint is the default but is only meant to be used for 1st and quasi 2nd order method. Use <code>diffMode=:forward</code> if you want to use something like Newton&#39;s methdd </li></ul><p><strong>Returns</strong></p><ul><li>A tuple containing the optimized parameters and the corresponding minimum cost function value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">result = optimizeParameters(qaoa, params, method=Optim.BFGS(linesearch=Optim.HagerZhang()), printout=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/optimization_settings.jl#L25-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.permuteHessian-Tuple{Type{&lt;:Real}, Int64, Int64}" href="#QAOALandscapes.permuteHessian-Tuple{Type{&lt;:Real}, Int64, Int64}"><code>QAOALandscapes.permuteHessian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permuteHessian(depth::Int, i::Int; tsType=&quot;symmetric&quot;)</code></pre><p>Computes the permutation that takes the Hessian at a particular transition state into the form described in the paper Basically, the last two rows and columns of the transformed Hessian correspond to the indexes where the zeros were inserted.</p><p><strong>Arguments</strong></p><ul><li><code>depth::Int</code>: Circuit depth of the transition state.</li><li><code>i::Int</code>: Index of the γ component at which the zero is added. If <code>tsType=&#39;symmetric&#39;</code> then <code>β=i</code>, otherwise if <code>tsType=&#39;non_symmetric&#39;</code> <code>β=i-1</code>.</li></ul><p><strong>Return</strong></p><ul><li><code>listOfIndices::Vector{Int64}</code>: List of indices correponding to the arrangement of the new basis elements.</li><li><code>permMat::Matrix{Float64}</code>: Matrix implementing the desired permutation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/hessian_tools.jl#L40-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.permuteHessian-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T&lt;:Real" href="#QAOALandscapes.permuteHessian-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T&lt;:Real"><code>QAOALandscapes.permuteHessian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permuteHessian(H::AbstractArray{Float64,2}, i::Int; tsType=&quot;symmetric&quot;)</code></pre><p>Computes the permutation that takes the Hessian at a particular transition state into the form described in the paper Basically, the last two rows and columns of the transformed Hessian correspond to the indexes where the zeros were inserted.</p><p><strong>Arguments</strong></p><ul><li><code>H::AbstractArray{Float64,2}</code>: Hessian at the transition state in the original basis.</li><li><code>i::Int</code>: Index of the γ component at which the zero is added. If <code>tsType=&#39;symmetric&#39;</code> then <code>β=i</code>, otherwise if <code>tsType=&#39;non_symmetric&#39;</code> <code>β=i-1</code>.</li></ul><p><strong>Return</strong></p><ul><li><code>listOfIndices::Vector{Int64}</code>: List of indices correponding to the arrangement of the new basis elements.</li><li><code>permMat::Matrix{Float64}</code>: Matrix implementing the desired permutation.</li><li><code>HTransformed::Matrix{Float64}</code>: Transformed Hessian at the transition state. Specifically, we have that <span>$H_{\mathop{\rm{perm}}}=PHP^{-1}$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/hessian_tools.jl#L77-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.rollDownInterp-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.rollDownInterp-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.rollDownInterp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rollDownInterp(qaoa::QAOA, Γmin::Vector{Float64}; method=Optim.BFGS(linesearch = Optim.BackTracking(order=3)))</code></pre><p>Starting from a local minima we construct a new vector using the INTERP initialization from which we perform the optimization. </p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA object </li><li><code>Γmin::Vector{Float64}</code>: Vector correponding to the local minimum from which we will construct the particular TS and then <strong>roll down</strong> from.</li></ul><p><strong>Optional</strong></p><ul><li><code>method=Optim.BFGS(linesearch = Optim.BackTracking(order=3))</code>: Default optimizer and linesearch choice. For more available choices see <a href="https://julianlsolvers.github.io/Optim.jl/stable/"><em>Optim.jl</em></a> </li></ul><p><strong>Return</strong></p><ul><li><code>result:Tuple</code>. The first element corresponds to the vector corresponding to which the algorithm converged to, and the second element is correponding energy_history</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/interp.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.rollDownTS-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.rollDownTS-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.rollDownTS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rollDownTS(qaoa::QAOA, Γmin::Vector{Float64}; ϵ=0.001, optim=Val(:BFGS))</code></pre><p>Starting from a local minima we construct all transition states (a total of 2p+1 of them). From each of the transition states, we construct two new vectors </p><p class="math-container">\[\Gamma^0_p = \Gamma_{\rm{TS}} + \epsilon \hat{e}_{\rm{min}}, 

\Gamma^0_m = \Gamma_{\rm{TS}} - \epsilon \hat{e}_{\rm{min}} \]</p><p>We then use these two vectors as initial points to carry out the optimization. Following our analytical results we are guarantee that the obtained vectors have lower energy than the initial vector <code>Γmin</code></p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA object </li><li><code>Γmin::Vector{Float64}</code>: Vector correponding to the local minimum from which we will construct the particular TS and then <strong>roll down</strong> from.</li></ul><p><strong>Return</strong></p><ul><li><code>result:Tuple</code>. The returned paramaters are as follows =&gt; <code>Γmin_m, Γmin_p, Emin_m, Emin_p, info_m, info_p</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/transition_states.jl#L100-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.rollDownfromTS-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, AbstractVector{T}, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.rollDownfromTS-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, AbstractVector{T}, Int64}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.rollDownfromTS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rollDownTS(qaoa::QAOA, Γmin::Vector{T}, ig::Int; ϵ=0.001, tsType=&quot;symmetric&quot;)</code></pre><p>Starting from a local minima we construct a vector corresponding to the transition state specified by <code>ig</code>. From there we construct two new vectors </p><p class="math-container">\[\Gamma^0_p = \Gamma_{\rm{TS}} + \epsilon \hat{e}_{\rm{min}},\]</p><p class="math-container">\[\Gamma^0_m = \Gamma_{\rm{TS}} - \epsilon \hat{e}_{\rm{min}} \]</p><p>We then use these two vectors as initial points to carry out the optimization. Following our analytical results we are guarantee that the obtained vectors have lower energy than the initial vector <code>Γmin</code></p><p><strong>Arguments</strong></p><ul><li><code>qaoa::QAOA</code>: QAOA object </li><li><code>Γmin::Vector{Float64}</code>: Vector correponding to the local minimum from which we will construct the particular TS and then <em>roll down</em> from.</li><li><code>ig::Int</code>: Index of the γ component where the zeros are inserted. </li><li><code>tsType=&quot;symmetric&quot;</code>: In this case, the index of the β component is equal to <code>ig</code>. Otherwise, the β index is <code>ig-1</code>.</li><li><code>optim=Val(:BFGS)</code>: Means that we will use the L-BFGS algorithm to perform the optimization. The other option is <code>optim=Val{:GD}</code>.</li></ul><p><strong>Return</strong></p><ul><li><code>result:Tuple</code>. The returned paramaters are as follows =&gt; <code>Γmin_m, Γmin_p, Emin_m, Emin_p, info_m, info_p</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/transition_states.jl#L54-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.spinChain-Tuple{Int64}" href="#QAOALandscapes.spinChain-Tuple{Int64}"><code>QAOALandscapes.spinChain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spinChain(n::Int; bcond=&quot;pbc&quot;)</code></pre><p>Constructs the graph for the classical Ising Hamiltonian on a chain with periodic boundary conditions determined by the <em>keyword</em> argument <code>bcond</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/utilities/utils.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.toFundamentalRegion!-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}" href="#QAOALandscapes.toFundamentalRegion!-Union{Tuple{T3}, Tuple{T}, Tuple{T1}, Tuple{QAOA{T1, T, T3}, Vector{T}}} where {T1&lt;:Graphs.AbstractGraph, T&lt;:Real, T3&lt;:AbstractBackend}"><code>QAOALandscapes.toFundamentalRegion!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">toFundamentalRegion!(qaoa::QAOA, Γ::Vector{Float64})</code></pre><p>Implements the symmetries of the QAOA for different graphs. For more detail see the following <a href="https://arxiv.org/abs/2209.01159"><code>reference</code></a>.</p><p>For an arbitrary graph, we can restrict both <span>$\gamma$</span> and <span>$\beta$</span> parameters to the <span>$[-\pi/2, \pi/2]$</span> interval. Furthermore, <span>$\beta$</span> parameters can be restricted even further to the <span>$[-\pi/4, \pi/4]$</span> interval (see <a href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.10.021067"><code>here</code></a>) Finally, when dealing with regular graphs with odd degree <code>\gamma</code> paramaters can be brought to the <span>$[-\pi/4, \pi/4]$</span> interval. This function modifies inplace the initial input vector <span>$Γ$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/base/parameters.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.transitionState-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real" href="#QAOALandscapes.transitionState-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>QAOALandscapes.transitionState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transitionState(Γp::Vector{Float64})</code></pre><p>Given an initial state <code>Γp::Vector{Float64}</code> of length <span>$2p$</span> it creates a matrix <span>$M_{\rm{TS}}$</span> of size <span>$2p+2 \times 2p+1$</span>.  The columns of <span>$M_{\rm{TS}}$</span> corresponds to the transition states associated with the initial minimum <code>Γp</code>. The first <code>p+1</code>  columns correspond to symmetric TS while the remaining <code>p</code> columns correspond to non-symmetric TS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/transition_states.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QAOALandscapes.transitionState-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T&lt;:Real" href="#QAOALandscapes.transitionState-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64}} where T&lt;:Real"><code>QAOALandscapes.transitionState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transitionState(Γp::Vector{Float64}, i::Int; tsType=&#39;symmetric&#39;)</code></pre><p>Given an initial state <code>Γp::Vector{Float64}</code> of length <code>2p</code> it creates another vector <code>ΓTs</code> of size <code>2p+2</code> such that the <code>i</code>-th γ component of <code>ΓTs</code> is 0 and the <code>i</code>-th (<code>i-1</code>-th)  β component of <code>ΓTs</code> is zero if <code>tsType=&#39;symmetric&#39;</code> (<code>tsType=&#39;non_symmetric&#39;</code>) while all the other components are the same as <code>Γp</code></p><p><strong>Keyword arguments</strong></p><ul><li><code>tsType=&#39;symmetric&#39;</code> Only strings values &#39;symmetric&#39; and &#39;non_symmetric&#39; are accepted</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaimelMedina/QAOALandscapes.jl/blob/1d9393e71f5a4c8ec476b9569be83eb71918bb83/src/initializations/transition_states.jl#L1-L11">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« QAOALandscapes</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 29 January 2024 16:24">Monday 29 January 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
